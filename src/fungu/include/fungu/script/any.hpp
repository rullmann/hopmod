/*
 * The Fungu Scripting Engine Library
 *
 * (C) Copyright 2008 Graham Daws
 * (C) Copyright 2005 Christopher Diggins
 * (C) Copyright 2005 Pablo Aguilar
 * (C) Copyright 2001 Kevlin Henney
 *
 *  Boost Software License - Version 1.0 - August 17th, 2003
 *
 *  Permission is hereby granted, free of charge, to any person or organization
 *  obtaining a copy of the software and accompanying documentation covered by
 *  this license (the "Software") to use, reproduce, display, distribute,
 *  execute, and transmit the Software, and to prepare derivative works of the
 *  Software, and to permit third-parties to whom the Software is furnished to
 *  do so, all subject to the following:
 *
 *  The copyright notices in the Software and this entire statement, including
 *  the above license grant, this restriction and the following disclaimer,
 *  must be included in all copies of the Software, in whole or in part, and
 *  all derivative works of the Software, unless such copies or derivative
 *  works are solely in the form of machine-executable object code generated by
 *  a source language processor.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */
#ifndef FUNGU_SCRIPT_ANY_HPP
#define FUNGU_SCRIPT_ANY_HPP

#include "../string.hpp"
#include "dynamic_typecasting.hpp"
#include "lexical_cast_fwd.hpp"

#include <stdexcept>
#include <typeinfo>
#include <algorithm>
#include <boost/type_traits/remove_const.hpp>
#include <boost/type_traits/is_arithmetic.hpp>

namespace fungu{
namespace script{

struct bad_any_cast : std::bad_cast {
    bad_any_cast(const std::type_info& src, const std::type_info& dest)
      : from(src.name()), to(dest.name())
    { }
    virtual const char* what() {
      return "bad cast";
    }
    const char* from;
    const char* to;
};

namespace any_detail{struct empty;}
template<typename Target> Target lexical_cast(const any_detail::empty &){return Target();}

namespace any_detail {

// function pointer table

struct fxn_ptr_table {
  const std::type_info& (*get_type)();
  void (*static_delete)(void**);
  void (*clone)(void* const*, void**);
  void (*move)(void* const*,void**);
  const_string (*to_string)(void * const *);
  bool (*is_arithmetic)();
  dynamic_typecaster * (*get_dynamic_typecaster)(void * const *);
};

// static functions for small value-types

template<bool is_small>
struct fxns
{
  template<typename T>
  struct type {
    static const std::type_info& get_type() {
      return typeid(T);
    }
    static void static_delete(void** x) {
      reinterpret_cast<T*>(reinterpret_cast<void *>(x))->~T();
    }
    static void clone(void* const* src, void** dest) {
      new(dest) T(*reinterpret_cast<T const*>(src));
    }
    static void move(void* const* src, void** dest) {
      reinterpret_cast<T*>(reinterpret_cast<void *>(dest))->~T();
      new(reinterpret_cast<T*>(reinterpret_cast<void *>(dest))) T(*reinterpret_cast<T const*>(src));
    }
    static const_string to_string(void *const* src) {
        return lexical_cast<const_string>(*reinterpret_cast<const T *>(src));
    }
    static bool is_arithmetic()
    {
        return boost::is_arithmetic<T>::value;
    }
    static dynamic_typecaster * get_dynamic_typecaster(void * const * src)
    {
        static derived_dynamic_typecaster<T> typecaster;
        typecaster = derived_dynamic_typecaster<T>(reinterpret_cast<T const *>(src));
        return &typecaster;
    }
  };
};

// static functions for big value-types (bigger than a void*)

template<>
struct fxns<false>
{
  template<typename T>
  struct type {
    static const std::type_info& get_type() {
      return typeid(T);
    }
    static void static_delete(void** x) {
        delete(*reinterpret_cast<T**>(x));
    }
    static void clone(void* const* src, void** dest) {
      *dest = new T(**reinterpret_cast<T* const*>(src));
    }
    static void move(void* const* src, void** dest) {
      (*reinterpret_cast<T**>(dest))->~T();
      new(*reinterpret_cast<T**>(dest)) T(**reinterpret_cast<T* const*>(src));
    }
    static const_string to_string(void *const* src) {
        return lexical_cast<const_string>(**reinterpret_cast<T * const *>(src));
    }
    static bool is_arithmetic() {
        return boost::is_arithmetic<T>::value;
    }
    static dynamic_typecaster * get_dynamic_typecaster(void * const * src)
    {
        static derived_dynamic_typecaster<T> typecaster;
        typecaster = derived_dynamic_typecaster<T>(*reinterpret_cast<T * const *>(src));
        return &typecaster;
    }
  };
};

template<typename T>
struct get_table
{
  static const bool is_small = sizeof(T) <= sizeof(void*);

  static fxn_ptr_table* get()
  {
    static fxn_ptr_table static_table = {
      fxns<is_small>::template type<T>::get_type
    , fxns<is_small>::template type<T>::static_delete
    , fxns<is_small>::template type<T>::clone
    , fxns<is_small>::template type<T>::move
    , fxns<is_small>::template type<T>::to_string
    , fxns<is_small>::template type<T>::is_arithmetic
    , fxns<is_small>::template type<T>::get_dynamic_typecaster
    };
    return &static_table;
  }
};

struct empty {
};
} // namespace any_detail

struct any
{
    // structors
    template <typename T>
    any(const T& x) {
      table = any_detail::get_table<T>::get();
      if (sizeof(T) <= sizeof(void*)) {
        new(&object) T(x);
      }
      else {
        object = new T(x);
      }
    }
    
    any() {
      table = any_detail::get_table<any_detail::empty>::get();
      object = NULL;
    }

    any(const any& x) {
      table = any_detail::get_table<any_detail::empty>::get();
      assign(x);
    }

    ~any() {
      table->static_delete(&object);
    }
    
    // assignment
    
    any& assign(const any& x) {
      // are we copying between the same type?
      if (table == x.table) {
        // if so, we can avoid reallocation
        table->move(&x.object, &object);
      }
      else {
        reset();
        x.table->clone(&x.object, &object);
        table = x.table;
      }
      return *this;
    }

    template <typename T>
    any& assign(const T& x)
    {
      // are we copying between the same type?
      any_detail::fxn_ptr_table* x_table = any_detail::get_table<typename boost::remove_const<T>::type>::get();
      if (table == x_table) {
        // if so, we can avoid deallocating and resuse memory
        if (sizeof(T) <= sizeof(void*)) {
          void ** ptr = &object; //fixes strict-aliasing warning
          reinterpret_cast<T*>(reinterpret_cast<void *>(ptr))->~T();
          // create copy on-top of object pointer itself
          new(&object) T(x);
        }
        else {
          reinterpret_cast<T*>(object)->~T();
          // create copy on-top of old version
          new(object) T(x);
        }
      }
      else {
        reset();
        if (sizeof(T) <= sizeof(void*)) {
          // create copy on-top of object pointer itself
          new(&object) T(x);
          // update table pointer
          table = x_table;
        }
        else {
          object = new T(x);
          table = x_table;
        }
      }
      return *this;
    }

    // assignment operator
    template<typename T>
    any& operator=(T const& x) {
      return assign(x);
    }
    
    any& operator=(const any & x)
    {
        return assign(x);
    }

    // utility functions

    any& swap(any& x) {
      std::swap(table, x.table);
      std::swap(object, x.object);
      return *this;
    }

    const std::type_info& get_type() const {
      return table->get_type();
    }
    
    const_string to_string()const {
      return table->to_string(&object);
    }
    
    bool is_arithmetic()const
    {
        return table->is_arithmetic();
    }
    
    dynamic_typecaster * get_dynamic_typecaster()const
    {
        return table->get_dynamic_typecaster(&object);
    }
    
    bool empty() const {
      return table == any_detail::get_table<any_detail::empty>::get();
    }

    void reset()
    {
      if (empty()) return;
      table->static_delete(&object);
      table = any_detail::get_table<any_detail::empty>::get();
      object = NULL;
    }
    
    static any null_value()
    {
        return any();
    }
    
    // fields
    any_detail::fxn_ptr_table* table;
    void* object;
};

// boost::any-like casting

template<typename T>
T* any_cast(any* this_) {
    if (this_->get_type() != typeid(T)) {
        static T tmp;
        if(boost::is_arithmetic<T>::value && this_->is_arithmetic())
        {
            tmp = this_->get_dynamic_typecaster()->numeric_cast((T *)NULL);
            return &tmp;
        }
        if(this_->empty()) {tmp = T(); return &tmp;}
        return NULL;
    }
    if (sizeof(T) <= sizeof(void*)) {
        void ** ptr = &this_->object; //fixes strict-aliasing warning
        return reinterpret_cast<T*>(reinterpret_cast<void *>(ptr));
    }
    else {
        return reinterpret_cast<T*>(this_->object);
    }
}

template<typename T>
T const* any_cast(any const* this_) {
    return any_cast<T>(const_cast<any*>(this_));
}

template<typename T>
T const& any_cast(any const& this_){
    T * ptr = any_cast<T>(const_cast<any*>(&this_));
    if(!ptr) throw bad_any_cast(this_.get_type(), typeid(T));
    return *ptr;
}

inline bool any_is_string(const any & var)
{
    return var.get_type() == typeid(const_string);
}

struct any_traits
{
    typedef any any_type;
    typedef bad_any_cast exception_type;
    
    template<typename TargetType>
    static TargetType * cast(any_type * obj){return any_cast<TargetType>(obj);}
    
    template<typename TargetType>
    static TargetType const* cast(const any_type * obj) {return cast<TargetType>(const_cast<any_type*>(obj));}
    
    template<typename TargetType>
    static const TargetType & cast(const any_type & obj){return *cast<TargetType>(const_cast<any_type*>(&obj));}
};

} //namespace script
} //namespace fungu

#endif
